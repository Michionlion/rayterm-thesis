%
% $Id: ch02_relatedwork
%
%   *******************************************************************
%   * SEE THE MAIN FILE "AllegThesis.tex" FOR MORE INFORMATION.       *
%   *******************************************************************
\chapter{Related Work}\label{ch:relatedwork}

In this chapter, we will discuss related research papers, detail how they inform \name's development, and show the improvements of \name\ over similar systems.
First, we will conduct a high-level discussion of the first ray-tracing paper through to basic details on modern-day optimizations.
Following that, we will discuss two Github projects, one of which has already been utilized to create some of the figures in this document, such as Figure \ref{fig:unicode_mode_comparison}.

\section{Primary Sources}
% Seminal papers

\littlesection{The First Ray-Tracer}

The very first ray-tracing algorithm was developed by Arthur Appel in his 1968 paper {\it Some techniques for shading machine renderings of solids} \cite{appel1968some}.
His algorithm is now known as a ray casting algorithm -- it does not follow the approach we have seen so far.
Instead, rays are traced from a point light source to the object being shaded, and a plus symbol of varying size is rendered at that location, depending on the intensity of light at that point.
When a photographic negative is taken, light spots that were not hit by the rays (thereby darkening them) are now ``in shadow'', as the color levels were inverted.
Today, Appel's work is not normally considered a real ray-tracing algorithm.
However, his work informed much of the following research, especially his ideas and mathematics on light intensity.

\littlesection{The Breakthrough}

The next big entry to the ray-tracing field was Turner Whitted's 1980 paper {\it An Improved Illumination Model for Shaded Display} \cite{whitted1980improved}.
In this groundbreaking work, Whitted introduced the recursive ray-tracing algorithm we covered in Section~\ref{sec:introduction:raytracing}.
Whitted was not the first to use ray-tracing -- Arthur Appel had first pioneered the field over a decade ago, and some commercial applications were also emerging in the field of radiosity.
Whitted's real contribution was the idea for how to improve ray-tracing so that it could solve the problem of {\it global illumination}.
Global illumination was not yet formalized, but the idea was to somehow gather the effect of all light in the scene on every single point.
Recursive ray-tracing approximates this very well, and thus Whitted-style ray-tracing was born.
Even today, any simple recursive ray-tracing algorithms (like the one proposed for \name) are known as Whitted-style ray-tracers.

\littlesection{Formalization}

The path to fully photorealistic rendering was blazed soon after Whitted's paper.
The mathematical basis for all of ray-tracing and photorealistic rendering in general was published by James Kajiya in 1986 \cite{kajiya1986rendering}.
In his paper {\it The Rendering Equation}, he articulated a generalization for many different rendering algorithms; this generalization is shown as Equation~\ref{equation:the_rendering_equation} below.
Although the idea behind the rendering equation was not completely new, Kajiya presented it in a form especially suited for computer graphics using vector mathematics.
The equation also gives direction for more advanced and photorealistic rendering techniques, leading up to path-tracing.

\begin{equation}
  \label{equation:the_rendering_equation}
  I(x, x') = g(x, x') [\epsilon(x, x') + \int_{S} \rho(x, x',x'')I(x', x'')dx'']
\end{equation}

We will not give a full explanation of the rendering equation here.
The significant part for \name\ is the integral, since if we can approximate that, \name\ will be photorealistic.
In \name, we will use the rendering equation to inform the recursive ray generation, attempting to find areas of the integral where most of the light is incoming.
In the common case, all light will be from the direction of nearby light sources.
However, we can also bias newly generated rays towards areas where refracted light may exist, such as around glass materials.
Keeping this mathematical basis in mind as our implementation is built is critical, so that \name\ does not stray too far from photorealism.

\littlesection{Accelerated Intersections}

Ray-tracing requires intersection tests with every object in the scene.
If it were possible to drastically reduce the number of tests computed for each ray, perhaps by only testing the ray against objects in its general vicinity, massive speed increases would emerge.
As it turns out, this was first explored right after Whitted's original paper.
The Bounding Volume Hierarchy (BVH) acceleration structure was proposed in Steven Rubin and Turner Whitted's 1980 paper {\it A 3-dimensional representation for fast rendering of complex scenes} \cite{rubin1980}.

A BVH essentially groups objects into hierarchical organizations, with each group covering a larger area than the groups inside it.
Each group has a {\it bounding volume}, a geometric primitive that encloses all members of that group.
Ray-tracing intersections are done with the root group's bounding volume first, then progress down the hierarchy and potentially skip the vast majority of geometry in the scene, thereby speeding up computation.
There have been numerous improvements to this idea; however, BVHs continue to be an easy-to-implement and efficient acceleration structure \cite{prunier2017bvh}, and if there is development time, some form of BVH will be implemented in \name.

\littlesection{Parallelization}

Ray-tracing is inherently parallelizable, because each ray-tree is independent -- rays cannot collide, and one fragment's ray-tree does not affect another fragment's ray-tree.
Thus, there have been many opimizations that target enhanced hardware acceleration to enable massively parrallel ray-tracing.
The first example of this was {\it Design and Analysis of a Parallel Ray Tracing Computer}, a 1983 paper by John Cleary and others \cite{cleary1983design}.
In it, Cleary describes a computing system that is functionally similar to the Grapics Processing Units (GPUs) available today.
They were even able to build small prototypes, but calculated that a full blown system would cost \$50 million and be able to generate 1000 by 1000 pixel images in 0.15 seconds.
Sadly, 1983 chip technology had not yet progressed to the point where such a large multi-core processor was feasible.

However, all was not lost.
Much of the research done in this area led to the design of systems such as OptiX \cite{parker2010optix} (which we describe in Section~\ref{sec:method:hardware}), enabling projects like \name\ to benefit from the massive speed increases estimated by early papers.
Instead of a \$50 million monstrosity, relatively small GPU chips capable of the same performance are now available for only hundreds of dollars.

\section{Recent Results}

\littlesection{Terminal Images}

A small program available on Github was the original inspiration for some details of \name.
Called TerminalImageViewer (\texttt{tiv}) \cite{tivGithub}, it uses RGB ANSI escape codes and Unicode block characters to display images in a terminal window.
\name\ will use the same ideas to produce its own animated output.
Many of the example figures in this proposal were also created using \texttt{tiv}.
The algorithm behind \texttt{tiv} is a direct inspiration for the ray-to-character algorithms described in Section~\ref{sec:method:ray_character_algorithm}.
\name, however, improves upon TerminalImageViewer in a single, incredibly impactful way: the graphics produced are animated.
Fundamentally, \texttt{tiv} and \name\ are similar only in output format, while the purpose and internal workings are generally dissimilar.

\littlesection{Gaming with Termloop}

A stated goal of \name\ is to support future games that might use the terminal as a graphical display.
Games have utilized the terminal as a display mechanism for a long time -- text based adventure games were built with a terminal in mind, and RPGs also got their start with randomly generated levels displayed in 2D in a terminal window.
Termloop is a game engine built for the terminal \cite{termloop}.
It has a similar purpose to \name\ -- namely, to facilitate game creation in the terminal.
However, Termloop, like all other terminal game engines available today, has one glaring limitation: it is not 3D.
This one differentiating factor is huge; it means that no games can ever be made that don't fit into the strict field of two-dimensional graphics.
\name\ changes that, by allowing full 3D rendering in the terminal.
It doesn't have the other niceties such as collision detection, but the ultimate goal of \name\ -- beyond the stated goals in this proposal -- is to grow to provide the same level of support for 3D games that Termloop has for 2D games.
